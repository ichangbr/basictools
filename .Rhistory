freeMem(F, T)
roxygen2::roxygenise()
devtools::install_github("ichangbr/basictools")
class(matrix())
class(data.frame())
class()
class(tibble::tibble())
mat <- matrix(rnorm(250), nrow = 10)
mat
colMeans(mat)
rowMeans(mat)
length(rowMeans(mat))
apply(mat[,1:9], 1, mean)
apply(mat[,1:9], 2, mean)
length(apply(mat[,1:9], 2, mean))
length(apply(mat[,1:9], 1, mean))
Map(c, c(1,2,3) c(10,20,30))
Map(c, c(1,2,3), c(10,20,30))
seq(10, 9)
seq(1, 20, 2)
seq(1, 20, 2) + 1
mat <- matrix(1:24, nrow = 4)
mat
nMeans <- function(x, n, over = "c") {
if(over %in% c("c", "r", "col", "row")) stop("over must one of (\"c\", \"r\", \"col\", \"row\")")
mx <- ifelse(over %in% c("c", "col"), ncol(x), nrow(x))
}
nMeans(mat, 9, over = "hola")
nMeans <- function(x, n, over = "c") {
if(!over %in% c("c", "r", "col", "row")) stop("over must one of (\"c\", \"r\", \"col\", \"row\")")
mx <- ifelse(over %in% c("c", "col"), ncol(x), nrow(x))
}
nMeans(mat, 9, over = "hola")
nMeans <- function(x, n, over = "c") {
if(!over %in% c("c", "r", "col", "row")) stop("over must one of \"c\", \"r\", \"col\", \"row\"")
mx <- ifelse(over %in% c("c", "col"), ncol(x), nrow(x))
}
nMeans(mat, 9, over = "hola")
nMeans <- function(x, n, over = "c") {
if(!over %in% c("c", "r", "col", "row")) stop("over must one of \"c\", \"r\", \"col\", \"row\".")
mx <- ifelse(over %in% c("c", "col"), ncol(x), nrow(x))
}
nMeans(mat, 9, over = "hola")
nMeans(mat, 9)
nMeans(mat, 9, over = F)
ncol(mat)
ncol(mat)%%3
ncol(mat)%%5
nMeans <- function(x, over = "c", n) {
if(!over %in% c("c", "r", "col", "row")) stop("over must one of \"c\", \"r\", \"col\", \"row\".")
mx <- ifelse(over %in% c("c", "col"), ncol(x), nrow(x))
err_str <- ifelse(over %in% c("c", "col"), "columns", "rows")
if(mx%%n != 0) stop(sprintf("number of %s is not multiple of n", err_str))
}
nMeans(mat, 9, over = F)
nMeans(mat, 9)
nMeans(mat, n = 9)
nMeans(mat, n = 2)
nMeans <- function(x, n, over = "c") {
if(!over %in% c("c", "r", "col", "row")) stop("over must one of \"c\", \"r\", \"col\", \"row\".")
mx <- ifelse(over %in% c("c", "col"), ncol(x), nrow(x))
err_str <- ifelse(over %in% c("c", "col"), "columns", "rows")
if(mx%%n != 0) stop(sprintf("number of %s is not multiple of n", err_str))
}
nMeans(mat, 9)
nMeans <- function(x, n, over = "c") {
if(!over %in% c("c", "r", "col", "row")) stop("over must one of \"c\", \"r\", \"col\", \"row\".")
mx <- ifelse(over %in% c("c", "col"), ncol(x), nrow(x))
err_str <- ifelse(over %in% c("c", "col"), "columns", "rows")
if(mx%%n != 0) stop(sprintf("number of %s is not multiple of n", err_str))
print(seq(1,mx,n))
}
nMeans(mat, 2)
nMeans <- function(x, n, over = "c") {
if(!over %in% c("c", "r", "col", "row")) stop("over must one of \"c\", \"r\", \"col\", \"row\".")
mx <- ifelse(over %in% c("c", "col"), ncol(x), nrow(x))
err_str <- ifelse(over %in% c("c", "col"), "columns", "rows")
if(mx%%n != 0) stop(sprintf("number of %s is not multiple of n", err_str))
idxs <- seq(1,mx,n)
idxs <- Map(c, idxs, idxs + (n - 1))
print(idxs)
}
nMeans(mat, 2)
idxs <- seq(1,ncol(mat),2)
idxs <- Map(c, idxs, idxs + (2 - 1))
idxs
idxs
mat
n
n = 2
mat[,1:2]
mean(mat[,1:2])
apply(mat[,1:2], 1, mean)
Map(function(c) apply(mat[,c[1]:c[2]], 1, mean))
Map(function(c) apply(mat[,c[1]:c[2]], 1, mean), idxs)
cbind(Map(function(c) apply(mat[,c[1]:c[2]], 1, mean), idxs))
do.call(rbind, Map(function(c) apply(mat[,c[1]:c[2]], 1, mean), idxs))
do.call(cbind, Map(function(c) apply(mat[,c[1]:c[2]], 1, mean), idxs))
mat
mat <- matrix(1:24, nrow = 4, byrow = T)
do.call(cbind, Map(function(c) apply(mat[,c[1]:c[2]], 1, mean), idxs))
nMeans <- function(x, n, over = "c") {
# Error Messages
if(!over %in% c("c", "r", "col", "row")) stop("over must one of \"c\", \"r\", \"col\", \"row\".")
mx <- ifelse(over %in% c("c", "col"), ncol(x), nrow(x))
err_str <- ifelse(over %in% c("c", "col"), "columns", "rows")
marg <- ifelse(over %in% c("c", "col"), 1, 2)
if(mx%%n != 0) stop(sprintf("number of %s is not multiple of n", err_str))
idxs <- seq(1,mx,n)
idxs <- Map(c, idxs, idxs + (n - 1))
print(idxs)
}
nMeans <- function(x, n, over = "c") {
# Error Messages
if(!over %in% c("c", "r", "col", "row")) stop("over must one of \"c\", \"r\", \"col\", \"row\".")
mx <- ifelse(over %in% c("c", "col"), ncol(x), nrow(x))
err_str <- ifelse(over %in% c("c", "col"), "columns", "rows")
marg <- ifelse(over %in% c("c", "col"), 1, 2)
bind <- ifelse(over %in% c("c", "col"), cbind, rbind)
if(mx%%n != 0) stop(sprintf("number of %s is not multiple of n", err_str))
idxs <- seq(1,mx,n)
idxs <- Map(c, idxs, idxs + (n - 1))
return(
do.call(bind, Map(function(c) apply(x[,c[1]:c[2]], marg, mean), idxs))
)
}
nMeans(mat,2)
nMeans(mat,2, "r")
mat
nMeans(mat,2, "r")
nMeans <- function(x, n, over = "c") {
# Error Messages
if(!over %in% c("c", "r", "col", "row")) stop("over must one of \"c\", \"r\", \"col\", \"row\".")
mx <- ifelse(over %in% c("c", "col"), ncol(x), nrow(x))
err_str <- ifelse(over %in% c("c", "col"), "columns", "rows")
marg <- ifelse(over %in% c("c", "col"), 1, 2)
bind <- ifelse(over %in% c("c", "col"), cbind, rbind)
if(mx%%n != 0) stop(sprintf("number of %s is not multiple of n", err_str))
idxs <- seq(1,mx,n)
idxs <- Map(c, idxs, idxs + (n - 1))
print(marg)
return(
do.call(bind, Map(function(c) apply(x[,c[1]:c[2]], marg, mean), idxs))
)
}
nMeans(mat,2, "r")
do.call(cbind, Map(function(c) apply(mat[c[1]:c[2],], 2, mean), idxs))
nMeans <- function(x, n, over = "c") {
# Error Messages
if(!over %in% c("c", "r", "col", "row")) stop("over must one of \"c\", \"r\", \"col\", \"row\".")
mx <- ifelse(over %in% c("c", "col"), ncol(x), nrow(x))
err_str <- ifelse(over %in% c("c", "col"), "columns", "rows")
marg <- ifelse(over %in% c("c", "col"), 1, 2)
bind <- ifelse(over %in% c("c", "col"), cbind, rbind)
if(mx%%n != 0) stop(sprintf("number of %s is not multiple of n", err_str))
idxs <- seq(1,mx,n)
idxs <- Map(c, idxs, idxs + (n - 1))
print(marg)
return(
do.call(bind, Map(function(c) apply(x[c[1]:c[2],], marg, mean), idxs))
)
}
nMeans(mat,2, "r")
idxs <- seq(1:10,2)
idxs <- seq(1,10,2)
idxs
idxs <- Map(c, idxs, idxs + 1)
idxs
Map(list, :, idxs)
Map(list, c(), idxs)
Map(list, "a", idxs)
Map(list, c(), idxs)
lapply(idxs, sum)
mat[NULL, 1:10]
mat[NULL, 1:2]
mat[:, 1:2]
mat[, 1:2]
nMeans <- function(x, n, over = "c") {
# Error Messages
if(!over %in% c("c", "r", "col", "row")) stop("over must one of \"c\", \"r\", \"col\", \"row\".")
mx <- ifelse(over %in% c("c", "col"), ncol(x), nrow(x))
err_str <- ifelse(over %in% c("c", "col"), "columns", "rows")
marg <- ifelse(over %in% c("c", "col"), 1, 2)
bind <- ifelse(over %in% c("c", "col"), cbind, rbind)
if(mx%%n != 0) stop(sprintf("number of %s is not multiple of n", err_str))
idxs <- seq(1,mx,n)
idxs <- Map(c, idxs, idxs + (n - 1))
print(idxs)
}
nMeans(mat, 2, "row")
nMeans <- function(x, n, over = "c") {
# Error Messages
if(!over %in% c("c", "r", "col", "row")) stop("over must one of \"c\", \"r\", \"col\", \"row\".")
over_cols <- over %in% c("c", "col")
mx <- ifelse(over_cols, ncol(x), nrow(x))
err_str <- ifelse(over_cols, "columns", "rows")
marg <- ifelse(over_cols), 1, 2)
nMeans <- function(x, n, over = "c") {
# Error Messages
if(!over %in% c("c", "r", "col", "row")) stop("over must one of \"c\", \"r\", \"col\", \"row\".")
over_cols <- over %in% c("c", "col")
mx <- ifelse(over_cols, ncol(x), nrow(x))
err_str <- ifelse(over_cols, "columns", "rows")
marg <- ifelse(over_cols, 1, 2)
bind <- ifelse(over_cols, cbind, rbind)
if(mx%%n != 0) stop(sprintf("number of %s is not multiple of n", err_str))
idxs <- seq(1,mx,n)
idxs <- Map(c, idxs, idxs + (n - 1))
print(idxs)
if (over_cols) {
do.call(bind, Map(function(c) apply(x[, c[1]:c[2]], marg, mean), idxs))
} else {
do.call(bind, Map(function(c) apply(x[c[1]:c[2], ], marg, mean), idxs))
}
}
nMeans(mat, 2)
nMeans <- function(x, n, over = "c") {
# Error Messages
if(!over %in% c("c", "r", "col", "row")) stop("over must one of \"c\", \"r\", \"col\", \"row\".")
over_cols <- over %in% c("c", "col")
mx <- ifelse(over_cols, ncol(x), nrow(x))
err_str <- ifelse(over_cols, "columns", "rows")
marg <- ifelse(over_cols, 1, 2)
bind <- ifelse(over_cols, cbind, rbind)
if(mx%%n != 0) stop(sprintf("number of %s is not multiple of n", err_str))
idxs <- seq(1,mx,n)
idxs <- Map(c, idxs, idxs + (n - 1))
if (over_cols) {
do.call(bind, Map(function(c) apply(x[, c[1]:c[2]], marg, mean), idxs))
} else {
do.call(bind, Map(function(c) apply(x[c[1]:c[2], ], marg, mean), idxs))
}
}
nMeans(mat, 2)
nMeans(mat, 2, "r")
nMeans(as.data.frame(mat), 2, "r")
nMeans(tibble::as_tibble(mat), 2, "r")
nMeans(tibble::tibble(mat), 2, "r")
nMeans(tibble::tibble(mat), 2)
tibble::tibble(mat)
mat <- tibble::tibble(mat)
mat
nMeans(mat,2)
ncol(mat)
nrow(mat)
mat <- matrix(1:24, nrow = 4, byrow = T)
mat
library(tibble)
as_tibble(mat)
mat <- as_tibble(mat)
nMeans(mat)
nMeans(mat, n)
class(mat)
mat <- matrix(1:24, nrow = 4, byrow = T)
class(mat)
class(as.data.frame(mat))
nMeans <- function(x, n, over = "c") {
# Error Messages
if(!class(x)[1] %in% c("tbl_df", "matrix", "data.frame"))
if(!over %in% c("c", "r", "col", "row")) stop("over must one of \"c\", \"r\", \"col\", \"row\".")
over_cols <- over %in% c("c", "col")
mx <- ifelse(over_cols, ncol(x), nrow(x))
err_str <- ifelse(over_cols, "columns", "rows")
marg <- ifelse(over_cols, 1, 2)
bind <- ifelse(over_cols, cbind, rbind)
if(mx%%n != 0) stop(sprintf("number of %s is not multiple of n", err_str))
idxs <- seq(1,mx,n)
idxs <- Map(c, idxs, idxs + (n - 1))
if (over_cols) {
do.call(bind, Map(function(c) apply(x[, c[1]:c[2]], marg, mean), idxs))
} else {
do.call(bind, Map(function(c) apply(x[c[1]:c[2], ], marg, mean), idxs))
}
}
nMeans(mat, 2)
nMeans(as_tibble(mat), 2)
nMeans(as.data.frame(mat), 2)
class(nMeans(as.data.frame(mat), 2))
class(nMeans(as_tibble(mat), 2))
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
warnings()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
warnings()
devtools::install_github("ichangbr/basictools")
a <- mean
a(1,2,3)
mean(c(1,2,3))
nMeans <- function(x, n, over = "c", fun = NULL) {
# Error Messages
if(!class(x)[1] %in% c("tbl_df", "matrix", "data.frame")) stop("Input x must be a matrix, data.frame or tibble")
if(!over %in% c("c", "r", "col", "row")) stop("over must one of \"c\", \"r\", \"col\", \"row\".")
over_cols <- over %in% c("c", "col")
mx <- ifelse(over_cols, ncol(x), nrow(x))
err_str <- ifelse(over_cols, "columns", "rows")
marg <- ifelse(over_cols, 1, 2)
bind <- ifelse(over_cols, cbind, rbind)
if(mx%%n != 0) stop(sprintf("number of %s is not multiple of n", err_str))
fun <- ifelse(is.null(fun), mean, fun)
print(fun)
# idxs <- seq(1,mx,n)
# idxs <- Map(c, idxs, idxs + (n - 1))
# if (over_cols) {
#   do.call(bind, Map(function(c) apply(x[, c[1]:c[2]], marg, mean), idxs))
# } else {
#   do.call(bind, Map(function(c) apply(x[c[1]:c[2], ], marg, mean), idxs))
# }
}
nMeans(matrix(1:6,nrow=2), 2)
nMeans(matrix(1:6,nrow=3), 2)
nMeans(matrix(1:6,nrow=3), 2, fun = max)
nMeans <- function(x, n, over = "c", fun = NULL) {
# Error Messages
if(!class(x)[1] %in% c("tbl_df", "matrix", "data.frame")) stop("Input x must be a matrix, data.frame or tibble")
if(!over %in% c("c", "r", "col", "row")) stop("over must one of \"c\", \"r\", \"col\", \"row\".")
over_cols <- over %in% c("c", "col")
mx <- ifelse(over_cols, ncol(x), nrow(x))
err_str <- ifelse(over_cols, "columns", "rows")
marg <- ifelse(over_cols, 1, 2)
bind <- ifelse(over_cols, cbind, rbind)
if(mx%%n != 0) stop(sprintf("number of %s is not multiple of n", err_str))
fun <- ifelse(is.null(fun), mean, fun)
idxs <- seq(1,mx,n)
idxs <- Map(c, idxs, idxs + (n - 1))
if (over_cols) {
do.call(bind, Map(function(c) apply(x[, c[1]:c[2]], marg, mean), idxs))
} else {
do.call(bind, Map(function(c) apply(x[c[1]:c[2], ], marg, mean), idxs))
}
}
mat <- matrix(1:24, nrow = 4)
mat
mat <- matrix(1:24, nrow = 4, byrow = T)
mat
nMeans(mat, 2)
nMeans(mat, 2, fun = max)
mat
nMeans(mat, 2, fun = max)
nMeans <- function(x, n, over = "c", fun = NULL) {
# Error Messages
if(!class(x)[1] %in% c("tbl_df", "matrix", "data.frame")) stop("Input x must be a matrix, data.frame or tibble")
if(!over %in% c("c", "r", "col", "row")) stop("over must one of \"c\", \"r\", \"col\", \"row\".")
over_cols <- over %in% c("c", "col")
mx <- ifelse(over_cols, ncol(x), nrow(x))
err_str <- ifelse(over_cols, "columns", "rows")
marg <- ifelse(over_cols, 1, 2)
bind <- ifelse(over_cols, cbind, rbind)
if(mx%%n != 0) stop(sprintf("number of %s is not multiple of n", err_str))
f <- ifelse(is.null(fun), mean, fun)
idxs <- seq(1,mx,n)
idxs <- Map(c, idxs, idxs + (n - 1))
if (over_cols) {
do.call(bind, Map(function(c) apply(x[, c[1]:c[2]], marg, mean), idxs))
} else {
do.call(bind, Map(function(c) apply(x[c[1]:c[2], ], marg, mean), idxs))
}
}
nMeans(mat, 2, fun = max)
nMeans <- function(x, n, over = "c", fun = NULL) {
# Error Messages
if(!class(x)[1] %in% c("tbl_df", "matrix", "data.frame")) stop("Input x must be a matrix, data.frame or tibble")
if(!over %in% c("c", "r", "col", "row")) stop("over must one of \"c\", \"r\", \"col\", \"row\".")
over_cols <- over %in% c("c", "col")
mx <- ifelse(over_cols, ncol(x), nrow(x))
err_str <- ifelse(over_cols, "columns", "rows")
marg <- ifelse(over_cols, 1, 2)
bind <- ifelse(over_cols, cbind, rbind)
if(mx%%n != 0) stop(sprintf("number of %s is not multiple of n", err_str))
f <- ifelse(is.null(fun), mean, fun)
idxs <- seq(1,mx,n)
idxs <- Map(c, idxs, idxs + (n - 1))
if (over_cols) {
do.call(bind, Map(function(c) apply(x[, c[1]:c[2]], marg, fun), idxs))
} else {
do.call(bind, Map(function(c) apply(x[c[1]:c[2], ], marg, fun), idxs))
}
}
nMeans(mat, 2, fun = max)
roxygen2::roxygenise()
rm(list = c("nMeans"))
roxygen2::roxygenise()
?nMeans
?freeMem
update.packages("roxygen2")
roxygen2::roxygenise()
?freeMem
roxygen2::roxygenise()
a <- c(1,2,3,NA,5)
max(a, na.rm = T)
nMeans <- function(x, n, over = "c", fun = NULL) {
# Error Messages
if(!class(x)[1] %in% c("tbl_df", "matrix", "data.frame")) stop("Input x must be a matrix, data.frame or tibble")
if(!over %in% c("c", "r", "col", "row")) stop("over must one of \"c\", \"r\", \"col\", \"row\".")
over_cols <- over %in% c("c", "col")
mx <- ifelse(over_cols, ncol(x), nrow(x))
err_str <- ifelse(over_cols, "columns", "rows")
marg <- ifelse(over_cols, 1, 2) # Margin
bind <- ifelse(over_cols, cbind, rbind)
if(mx%%n != 0) stop(sprintf("number of %s is not multiple of n", err_str))
f <- ifelse(is.null(fun), mean, fun)
idxs <- seq(1,mx,n)
idxs <- Map(c, idxs, idxs + (n - 1))
if (over_cols) {
do.call(bind, Map(function(c) apply(x[, c[1]:c[2]], marg, f, na.rm = T), idxs))
} else {
do.call(bind, Map(function(c) apply(x[c[1]:c[2], ], marg, f, na.rm = T), idxs))
}
}
mat <- matrix(1:24, nrow = 4, byrow = T)
mat
nMeans(mat, 2)
mat[,3]
mat[,3] <- NA
mat
nMeans(mat, 2)
# _ ____ ___
# | |___ |==]
# ---
# CREATED: 05.05.2023
# LAST MODIFIED: 05.05.2023
#' Calculate the means of matrix-like objects divided into equal-sized groups
#'
#' @param x A matrix or data frame.
#' @param n An integer specifying the number of columns or rows to group together.
#' @param over A character string indicating whether to group by columns ("c" or "col") or rows ("r" or "row").
#' @param fun An optional function to apply to each group. Defaults to \code{mean}.
#'
#' @return A matrix or data frame with the means of every n columns or rows.
#'
#' @details
#' The function takes in a matrix or data frame \code{x} and groups the data by every \code{n} columns or rows, depending on whether \code{over} is set to "c"/"col" or "r"/"row", respectively.
#'
#' If \code{over} is set to "c"/"col", the selected columns and all rows will be used to calculate the means, while if \code{over} is set to "r"/"row", the selected rows and all columns will be used.
#'
#' If \code{x} is a tibble, the resulting data will be returned as a tibble; otherwise, it will be returned as a matrix or data frame depending on the class of the input.
#'
#' @examples
#' nMeans(matrix(1:9, ncol = 3), 2, over = "col")
#' nMeans(data.frame(matrix(1:9, ncol = 3)), 2, over = "row")
#'
#' @export
nMeans <- function(x, n, over = "c", fun = NULL) {
# Error Messages
if(!class(x)[1] %in% c("tbl_df", "matrix", "data.frame")) stop("Input x must be a matrix, data.frame or tibble")
if(!over %in% c("c", "r", "col", "row")) stop("over must one of \"c\", \"r\", \"col\", \"row\".")
over_cols <- over %in% c("c", "col")
mx <- ifelse(over_cols, ncol(x), nrow(x))
err_str <- ifelse(over_cols, "columns", "rows")
marg <- ifelse(over_cols, 1, 2) # Margin
bind <- ifelse(over_cols, cbind, rbind)
if(mx%%n != 0) stop(sprintf("number of %s is not multiple of n", err_str))
f <- ifelse(is.null(fun), mean, fun)
idxs <- seq(1,mx,n)
idxs <- Map(c, idxs, idxs + (n - 1))
if (over_cols) {
do.call(bind, Map(function(c) apply(x[, c[1]:c[2]], marg, f, na.rm = F), idxs))
} else {
do.call(bind, Map(function(c) apply(x[c[1]:c[2], ], marg, f, na.rm = F), idxs))
}
}
nMeans(mat, 2)
# _ ____ ___
# | |___ |==]
# ---
# CREATED: 05.05.2023
# LAST MODIFIED: 05.05.2023
#' Calculate the means of matrix-like objects divided into equal-sized groups
#'
#' @param x A matrix or data frame.
#' @param n An integer specifying the number of columns or rows to group together.
#' @param over A character string indicating whether to group by columns ("c" or "col") or rows ("r" or "row").
#' @param fun An optional function to apply to each group. Defaults to \code{mean}.
#'
#' @return A matrix or data frame with the means of every n columns or rows.
#'
#' @details
#' The function takes in a matrix or data frame \code{x} and groups the data by every \code{n} columns or rows, depending on whether \code{over} is set to "c"/"col" or "r"/"row", respectively.
#'
#' If \code{over} is set to "c"/"col", the selected columns and all rows will be used to calculate the means, while if \code{over} is set to "r"/"row", the selected rows and all columns will be used.
#'
#' If \code{x} is a tibble, the resulting data will be returned as a tibble; otherwise, it will be returned as a matrix or data frame depending on the class of the input.
#'
#' @examples
#' nMeans(matrix(1:9, ncol = 3), 2, over = "col")
#' nMeans(data.frame(matrix(1:9, ncol = 3)), 2, over = "row")
#'
#' @export
nMeans <- function(x, n, over = "c", fun = NULL) {
# Error Messages
if(!class(x)[1] %in% c("tbl_df", "matrix", "data.frame")) stop("Input x must be a matrix, data.frame or tibble")
if(!over %in% c("c", "r", "col", "row")) stop("over must one of \"c\", \"r\", \"col\", \"row\".")
over_cols <- over %in% c("c", "col")
mx <- ifelse(over_cols, ncol(x), nrow(x))
err_str <- ifelse(over_cols, "columns", "rows")
marg <- ifelse(over_cols, 1, 2) # Margin
bind <- ifelse(over_cols, cbind, rbind)
if(mx%%n != 0) stop(sprintf("number of %s is not multiple of n", err_str))
f <- ifelse(is.null(fun), mean, fun)
idxs <- seq(1,mx,n)
idxs <- Map(c, idxs, idxs + (n - 1))
if (over_cols) {
do.call(bind, Map(function(c) apply(x[, c[1]:c[2]], marg, f, na.rm = T), idxs))
} else {
do.call(bind, Map(function(c) apply(x[c[1]:c[2], ], marg, f, na.rm = T), idxs))
}
}
nMeans(mat, 2)
