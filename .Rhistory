?freeMem
roxygen2::roxygenise()
a <- c(1,2,3,NA,5)
max(a, na.rm = T)
nMeans <- function(x, n, over = "c", fun = NULL) {
# Error Messages
if(!class(x)[1] %in% c("tbl_df", "matrix", "data.frame")) stop("Input x must be a matrix, data.frame or tibble")
if(!over %in% c("c", "r", "col", "row")) stop("over must one of \"c\", \"r\", \"col\", \"row\".")
over_cols <- over %in% c("c", "col")
mx <- ifelse(over_cols, ncol(x), nrow(x))
err_str <- ifelse(over_cols, "columns", "rows")
marg <- ifelse(over_cols, 1, 2) # Margin
bind <- ifelse(over_cols, cbind, rbind)
if(mx%%n != 0) stop(sprintf("number of %s is not multiple of n", err_str))
f <- ifelse(is.null(fun), mean, fun)
idxs <- seq(1,mx,n)
idxs <- Map(c, idxs, idxs + (n - 1))
if (over_cols) {
do.call(bind, Map(function(c) apply(x[, c[1]:c[2]], marg, f, na.rm = T), idxs))
} else {
do.call(bind, Map(function(c) apply(x[c[1]:c[2], ], marg, f, na.rm = T), idxs))
}
}
mat <- matrix(1:24, nrow = 4, byrow = T)
mat
nMeans(mat, 2)
mat[,3]
mat[,3] <- NA
mat
nMeans(mat, 2)
# _ ____ ___
# | |___ |==]
# ---
# CREATED: 05.05.2023
# LAST MODIFIED: 05.05.2023
#' Calculate the means of matrix-like objects divided into equal-sized groups
#'
#' @param x A matrix or data frame.
#' @param n An integer specifying the number of columns or rows to group together.
#' @param over A character string indicating whether to group by columns ("c" or "col") or rows ("r" or "row").
#' @param fun An optional function to apply to each group. Defaults to \code{mean}.
#'
#' @return A matrix or data frame with the means of every n columns or rows.
#'
#' @details
#' The function takes in a matrix or data frame \code{x} and groups the data by every \code{n} columns or rows, depending on whether \code{over} is set to "c"/"col" or "r"/"row", respectively.
#'
#' If \code{over} is set to "c"/"col", the selected columns and all rows will be used to calculate the means, while if \code{over} is set to "r"/"row", the selected rows and all columns will be used.
#'
#' If \code{x} is a tibble, the resulting data will be returned as a tibble; otherwise, it will be returned as a matrix or data frame depending on the class of the input.
#'
#' @examples
#' nMeans(matrix(1:9, ncol = 3), 2, over = "col")
#' nMeans(data.frame(matrix(1:9, ncol = 3)), 2, over = "row")
#'
#' @export
nMeans <- function(x, n, over = "c", fun = NULL) {
# Error Messages
if(!class(x)[1] %in% c("tbl_df", "matrix", "data.frame")) stop("Input x must be a matrix, data.frame or tibble")
if(!over %in% c("c", "r", "col", "row")) stop("over must one of \"c\", \"r\", \"col\", \"row\".")
over_cols <- over %in% c("c", "col")
mx <- ifelse(over_cols, ncol(x), nrow(x))
err_str <- ifelse(over_cols, "columns", "rows")
marg <- ifelse(over_cols, 1, 2) # Margin
bind <- ifelse(over_cols, cbind, rbind)
if(mx%%n != 0) stop(sprintf("number of %s is not multiple of n", err_str))
f <- ifelse(is.null(fun), mean, fun)
idxs <- seq(1,mx,n)
idxs <- Map(c, idxs, idxs + (n - 1))
if (over_cols) {
do.call(bind, Map(function(c) apply(x[, c[1]:c[2]], marg, f, na.rm = F), idxs))
} else {
do.call(bind, Map(function(c) apply(x[c[1]:c[2], ], marg, f, na.rm = F), idxs))
}
}
nMeans(mat, 2)
# _ ____ ___
# | |___ |==]
# ---
# CREATED: 05.05.2023
# LAST MODIFIED: 05.05.2023
#' Calculate the means of matrix-like objects divided into equal-sized groups
#'
#' @param x A matrix or data frame.
#' @param n An integer specifying the number of columns or rows to group together.
#' @param over A character string indicating whether to group by columns ("c" or "col") or rows ("r" or "row").
#' @param fun An optional function to apply to each group. Defaults to \code{mean}.
#'
#' @return A matrix or data frame with the means of every n columns or rows.
#'
#' @details
#' The function takes in a matrix or data frame \code{x} and groups the data by every \code{n} columns or rows, depending on whether \code{over} is set to "c"/"col" or "r"/"row", respectively.
#'
#' If \code{over} is set to "c"/"col", the selected columns and all rows will be used to calculate the means, while if \code{over} is set to "r"/"row", the selected rows and all columns will be used.
#'
#' If \code{x} is a tibble, the resulting data will be returned as a tibble; otherwise, it will be returned as a matrix or data frame depending on the class of the input.
#'
#' @examples
#' nMeans(matrix(1:9, ncol = 3), 2, over = "col")
#' nMeans(data.frame(matrix(1:9, ncol = 3)), 2, over = "row")
#'
#' @export
nMeans <- function(x, n, over = "c", fun = NULL) {
# Error Messages
if(!class(x)[1] %in% c("tbl_df", "matrix", "data.frame")) stop("Input x must be a matrix, data.frame or tibble")
if(!over %in% c("c", "r", "col", "row")) stop("over must one of \"c\", \"r\", \"col\", \"row\".")
over_cols <- over %in% c("c", "col")
mx <- ifelse(over_cols, ncol(x), nrow(x))
err_str <- ifelse(over_cols, "columns", "rows")
marg <- ifelse(over_cols, 1, 2) # Margin
bind <- ifelse(over_cols, cbind, rbind)
if(mx%%n != 0) stop(sprintf("number of %s is not multiple of n", err_str))
f <- ifelse(is.null(fun), mean, fun)
idxs <- seq(1,mx,n)
idxs <- Map(c, idxs, idxs + (n - 1))
if (over_cols) {
do.call(bind, Map(function(c) apply(x[, c[1]:c[2]], marg, f, na.rm = T), idxs))
} else {
do.call(bind, Map(function(c) apply(x[c[1]:c[2], ], marg, f, na.rm = T), idxs))
}
}
nMeans(mat, 2)
mat <- matrix(1:24, nrow = 4)
mat
mat[1,3] <- -Inf
mat
mat[2,1] <- -Inf
mat[4,3] <- -Inf
mat
mat[3,5] <- -Inf
mat
as_tibble(mat)
apply(mat,2)
apply(mat,2, max)
apply(mat,2, function(x) is.infinite)
apply(mat,2, function(x) is.infinite(x))
apply(mat,2, function(x) print(x))
apply(mat,2, function(x) {x[is.infinite(x)] <- NA; return(x)})
lapply(mat,2, function(x) {x[is.infinite(x)] <- NA; return(x)})
apply(mat,2, function(x) {x[is.infinite(x)] <- NA; return(x)})
is.infinite(x)
is.infinite(mat)
is.infinite(as.data.frame(mat))
apply(as.data.frame(mat),2, function(x) {x[is.infinite(x)] <- NA; return(x)})
apply(tibble::as_tibble(mat),2, function(x) {x[is.infinite(x)] <- NA; return(x)})
names(mat)
name(mat) <- letters[1:6]
names(mat) <- letters[1:6]
mat
mat <- matrix(1:24, nrow = 4)
mat[1,2] <- -Inf
mat[2,3] <- -Inf
mat[4,6] <- -Inf
mat
colnames(mat)
colnames(mat) <- letters[1:6]
mat
apply(tibble::as_tibble(mat),2, function(x) {x[is.infinite(x)] <- NA; return(x)})
subsInf <- function(x, replace_with = NA) {
return(
apply(x,2,function(x) {x[is.infinite(x)] <- replace_with; return(x)})
)
}
subsInf(mat, 100)
subsInf(matrix(c(1, 2, -Inf, 4, 5, 6, Inf, Inf, 9), nrow = 3), replace_with = -999)
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
search()
a <- search()
class(a)
grep("^packages:". a)
grep("^packages:", a)
grep("^packages:", "packages:base")
grep("^packages:", a)
grep("^package:", a)
a[grep("^package:", a)]
gsub("^package:", "", a[grep("^package:", a)])
library(basictools)
gsub("^package:", "", a[grep("^package:", a)])
search()
sprintf("%s",a)
sprintf("%s, %s",a)
sprintf("%s, %s",a, a)
paste(a)
gsub("^package:", "", a[grep("^package:", a)])
prov <- gsub("^package:", "", a[grep("^package:", a)])
prov
search()
detach("basictools")
detach("basictools", unload = T)
detach("basictools", unload = T, character.only = T)
detach("package:basictools", unload = T, character.only = T)
search()
prov <- a[grep("^package:", a)]
prov
paste(prov)
paste(prov, collapse = ", ")
paste("c(",paste(prov, collapse = ", "),")", sep = "")
print(paste("c(",paste(prov, collapse = ", "),")", sep = ""))
print(paste("c(",paste(prov, collapse = '", '),")", sep = ""))
print(paste("c(",paste(prov, collapse = '\", '),")", sep = ""))
print(paste("c(",paste(prov, collapse = ", "),")", sep = ""))
print(paste("c(",paste(prov, collapse = "', "),")", sep = ""))
print(paste("c('",paste(prov, collapse = "', "),"')", sep = ""))
print(paste("c('",paste(prov, collapse = "', '"),"')", sep = ""))
loadedNamespaces()
loaded <- search()
loaded
pckgs <- loaded[grep("^package:", loaded),]
pckgs <- loaded[grep("^package:", loaded)]
pckgs
keep <- c('package:stats', 'package:graphics', 'package:grDevices', 'package:utils', 'package:datasets', 'package:methods', 'package:base')
setdiff(pckgs,keep)
library(basictools)
keep <- c('package:stats', 'package:graphics', 'package:grDevices', 'package:utils', 'package:datasets', 'package:methods', 'package:base')
loaded <- search()
pckgs <- loaded[grep("^package:", loaded)]
setdiff(pckgs, keep)
setdiff(keep, pckgs)
setdiff(pckgs,keep)
pckgs2rem <- setdiff(pckgs, keep)
pckgs2rem
sapply(pckgs2rem, detach)
pckgs2rem
for (pkg in pckgs2rem) {
detach(pkg, character.only = T, unload = T)
}
search()
library(basictools)
base <- c('package:stats', 'package:graphics', 'package:grDevices', 'package:utils', 'package:datasets', 'package:methods', 'package:base')
loaded <- search()
pckgs <- loaded[grep("^package:", loaded)]
pckgs2rem <- setdiff(pckgs, keep)
pckgs2rem <- setdiff(pckgs, base)
pckgs2rem
paste0("package:", c("basictools", "ggplot2"))
library(ggplot2)
clearLibs <- function(keep = NULL) {
base <- c('package:stats', 'package:graphics', 'package:grDevices', 'package:utils', 'package:datasets', 'package:methods', 'package:base')
loaded <- search()
pckgs <- loaded[grep("^package:", loaded)]
if (!is.null(keep)) {
if (!is.character(keep)) stop("keep must be character")
keep <- paste0("package:", keep)
pckgs <- setdiff(pckgs, keep)
}
pckgs2rem <- setdiff(pckgs, base)
print(pckgs2rem)
# for (pkg in pckgs2rem) {
#   detach(pkg, character.only = T, unload = T)
# }
}
clearLibs(c("basictools"))
clearLibs <- function(keep = NULL) {
base <- c('package:stats', 'package:graphics', 'package:grDevices', 'package:utils', 'package:datasets', 'package:methods', 'package:base')
loaded <- search()
pckgs <- loaded[grep("^package:", loaded)]
if (!is.null(keep)) {
if (!is.character(keep)) stop("keep must be character")
keep <- paste0("package:", keep)
pckgs <- setdiff(pckgs, keep)
}
pckgs2rem <- setdiff(pckgs, base)
for (pkg in pckgs2rem) {
detach(pkg, character.only = T, unload = T)
}
}
clearLibs <- function(keep = NULL) {
base <- c('package:stats', 'package:graphics', 'package:grDevices', 'package:utils', 'package:datasets', 'package:methods', 'package:base')
loaded <- search()
pckgs <- loaded[grep("^package:", loaded)]
if (!is.null(keep)) {
if (!is.character(keep)) stop("keep must be character")
keep <- paste0("package:", keep)
pckgs <- setdiff(pckgs, keep)
}
pckgs2rem <- setdiff(pckgs, base)
print(pckgs2rem)
# for (pkg in pckgs2rem) {
#   detach(pkg, character.only = T, unload = T)
# }
}
clearLibs(c(1))
clearLibs("basictools")
clearLibs <- function(keep = NULL) {
base <- c('package:stats', 'package:graphics', 'package:grDevices', 'package:utils', 'package:datasets', 'package:methods', 'package:base')
loaded <- search()
pckgs <- loaded[grep("^package:", loaded)]
if (!is.null(keep)) {
if (!all(keep %in% pckgs)) stop("element of keep not attached")
if (!is.character(keep)) stop("keep must be character")
keep <- paste0("package:", keep)
pckgs <- setdiff(pckgs, keep)
}
pckgs2rem <- setdiff(pckgs, base)
print(pckgs2rem)
# for (pkg in pckgs2rem) {
#   detach(pkg, character.only = T, unload = T)
# }
}
clearLibs("bastools")
clearLibs(c("bastools", "ggplot2"))
clearLibs(c("basictools", "ggplot2"))
clearLibs <- function(keep = NULL) {
base <- c('package:stats', 'package:graphics', 'package:grDevices', 'package:utils', 'package:datasets', 'package:methods', 'package:base')
loaded <- search()
pckgs <- loaded[grep("^package:", loaded)]
if (!is.null(keep)) {
if (!is.character(keep)) stop("keep must be character")
keep <- paste0("package:", keep)
if (!all(keep %in% pckgs)) stop("element of keep not attached")
pckgs <- setdiff(pckgs, keep)
}
pckgs2rem <- setdiff(pckgs, base)
print(pckgs2rem)
# for (pkg in pckgs2rem) {
#   detach(pkg, character.only = T, unload = T)
# }
}
clearLibs(c("basictools", "ggplot2"))
clearLibs(c("bastools", "ggplot2"))
clearLibs(c("basictools", "ggplot2"))
clearLibs(c("basictools"))
clearLibs <- function(vect = NULL) {
base <- c('package:stats', 'package:graphics', 'package:grDevices', 'package:utils', 'package:datasets', 'package:methods', 'package:base')
loaded <- search()
pckgs <- loaded[grep("^package:", loaded)]
if (!is.null(keep)) {
if (!is.character(keep)) stop("keep must be character")
keep <- paste0("package:", keep)
if (!all(keep %in% pckgs)) stop("element of keep not attached")
pckgs <- setdiff(pckgs, keep)
}
pckgs2rem <- setdiff(pckgs, base)
print(pckgs2rem)
for (pkg in pckgs2rem) {
detach(pkg, character.only = T, unload = T)
}
}
clearLibs(c("basictools"))
clearLibs(c("basictools"))
clearLibs <- function(vect = NULL) {
base <- c('package:stats', 'package:graphics', 'package:grDevices', 'package:utils', 'package:datasets', 'package:methods', 'package:base')
loaded <- search()
pckgs <- loaded[grep("^package:", loaded)]
if (!is.null(vect)) {
if (!is.character(vect)) stop("vect must be character")
vect <- paste0("package:", vect)
if (!all(vect %in% pckgs)) stop("element of vect not attached")
pckgs <- setdiff(pckgs, vect)
}
pckgs2rem <- setdiff(pckgs, base)
print(pckgs2rem)
for (pkg in pckgs2rem) {
detach(pkg, character.only = T, unload = T)
}
}
clearLibs(c("basictools"))
search()
library(ggplot2)
clearLibs(c("basictools"))
a <- c("hola", "ignacio")
patt <- "{1} soy {2}"
print(pat)
print(patt)
gregexpr("\\{(\\d+)\\}", patt)
regmatches(patt, gregexpr("\\{(\\d+)\\}", patt))
regmatches(patt, gregexpr("(?<=\\{).(?=\\})", patt))
regmatches(patt, gregexpr("(?<=\\{).+(?=\\})", patt))
gregexpr("(?<=\\{).+(?=\\})", patt)
gregexpr("(?<=\{).+?(?=\})", patt)
gregexpr("(?<=\\{).+?(?=\\})", patt)
gregexpr("\\{.+?\\}", patt)
gregexpr("(?<=\\{).+?(?=\\})", patt, perl = T)
regmatches(patt, gregexpr("(?<=\\{).+(?=\\})", patt, perl = T))
regmatches(patt, gregexpr("(?<=\\{).+?(?=\\})", patt, perl = T))
patt = "{1}, soy {3} {2}"
regmatches(patt, gregexpr("(?<=\\{).+?(?=\\})", patt, perl = T))
regmatches(patt, gregexpr("(?<=\\{).+?(?=\\})", patt, perl = T))[[1]]
as.numeric(regmatches(patt, gregexpr("(?<=\\{).+?(?=\\})", patt, perl = T))[[1]])
fstring <- function(pat, vect) {
idxs <- as.numeric(regmatches(patt, gregexpr("(?<=\\{).+?(?=\\})", pat, perl = T))[[1]])
print(idxs)
}
fstring("{2} soy {1}")
fstring("{2} soy {1}", c(1))
fstring <- function(pat, vect) {
idxs <- as.numeric(regmatches(pat, gregexpr("(?<=\\{).+?(?=\\})", pat, perl = T))[[1]])
print(idxs)
}
fstring("{2} soy {1}", c(1))
fstring("{2} soy {1} {3}", c(1))
sapply(c(2,1,3), print)
fstring("{2} soy {1}", c(1))
fstring("{2} soy {1} {3}", c(1))
fstring <- function(pat, vect) {
idxs <- regmatches(pat, gregexpr("(?<=\\{).+?(?=\\})", pat, perl = T))[[1]]
}
fstring("{2} soy {1} {3}", c(1))
print(idxs)
fstring <- function(pat, vect) {
idxs <- as.numeric(regmatches(pat, gregexpr("(?<=\\{).+?(?=\\})", pat, perl = T))[[1]])
}
fstring <- function(pat, vect) {
idxs <- as.numeric(regmatches(pat, gregexpr("(?<=\\{).+?(?=\\})", pat, perl = T))[[1]])
print(idxs)
}
fstring <- function(pat, vect) {
idxs <- as.numeric(regmatches(pat, gregexpr("(?<=\\{).+?(?=\\})", pat, perl = T))[[1]])
for (i in idxs) {
print(paste0("{",vect[i],"}"))
}
}
fstring("{2} soy {1} {3}", c("Ignacio", "Hola", "Chang"))
fstring <- function(pat, vect) {
idxs <- as.numeric(regmatches(pat, gregexpr("(?<=\\{).+?(?=\\})", pat, perl = T))[[1]])
for (i in idxs) {
print(paste0("{",i,"}"))
}
}
fstring <- function(pat, vect) {
idxs <- as.numeric(regmatches(pat, gregexpr("(?<=\\{).+?(?=\\})", pat, perl = T))[[1]])
for (i in idxs) {
print(paste0("{",i,"}"))
}
}
fstring("{2} soy {1} {3}", c(1))
fstring <- function(pat, vect) {
idxs <- as.numeric(regmatches(pat, gregexpr("(?<=\\{).+?(?=\\})", pat, perl = T))[[1]])
for (i in idxs) {
a <- paste0("{",i,"}")
pat <- gsub(a, vect[i], pat)
print(pat)
}
}
fstring("{2} soy {1} {3}", c(1))
gsub("{2}","hola","{2}, soy")
gsub("\\{2\\}","hola","{2}, soy")
fstring <- function(pat, vect) {
idxs <- as.numeric(regmatches(pat, gregexpr("(?<=\\{).+?(?=\\})", pat, perl = T))[[1]])
for (i in idxs) {
a <- paste0("\\{",i,"\\}")
pat <- gsub(a, vect[i], pat)
print(pat)
}
}
fstring("{2} soy {1} {3}", c(1))
fstring <- function(pat, vect) {
idxs <- as.numeric(regmatches(pat, gregexpr("(?<=\\{).+?(?=\\})", pat, perl = T))[[1]])
for (i in idxs) {
a <- paste0("\\{",i,"\\}")
print(pat)
# pat <- gsub(a, vect[i], pat)
# print(pat)
}
}
fstring("{2} soy {1} {3}", c(1))
fstring <- function(pat, vect) {
idxs <- as.numeric(regmatches(pat, gregexpr("(?<=\\{).+?(?=\\})", pat, perl = T))[[1]])
for (i in idxs) {
a <- paste0("\\{",i,"\\}")
print(a)
# pat <- gsub()
# print(pat)
}
}
fstring("{2} soy {1} {3}", c(1))
fstring("{2} soy {1} {3}", c("Ignacio", "hola", "Chang"))
fstring <- function(pat, vect) {
idxs <- as.numeric(regmatches(pat, gregexpr("(?<=\\{).+?(?=\\})", pat, perl = T))[[1]])
for (i in idxs) {
a <- paste0("\\{",i,"\\}")
pat <- gsub(a, vect[i], pat)
print(pat)
}
}
fstring("{2} soy {1} {3}", c("Ignacio", "hola", "Chang"))
fstring <- function(pat, vect) {
idxs <- as.numeric(regmatches(pat, gregexpr("(?<=\\{).+?(?=\\})", pat, perl = T))[[1]])
invisible(lapply(idxs, function(i) { pat <<- gsub(paste0("\\{",i,"\\}"), vect[i], pat) }))
print(pat)
}
fstring("{2} soy {1} {3}", c("Ignacio", "hola", "Chang"))
fstring <- function(pat, vect) {
idxs <- as.numeric(regmatches(pat, gregexpr("(?<=\\{).+?(?=\\})", pat, perl = T))[[1]])
return(
invisible(lapply(idxs, function(i) { pat <<- gsub(paste0("\\{",i,"\\}"), vect[i], pat) }))
)
}
fstring("{2} soy {1} {3}", c("Ignacio", "hola", "Chang"))
fstring <- function(pat, vect) {
idxs <- as.numeric(regmatches(pat, gregexpr("(?<=\\{).+?(?=\\})", pat, perl = T))[[1]])
return(
invisible(lapply(idxs, function(i) { pat <<- gsub(paste0("\\{",i,"\\}"), vect[i], pat) }))
)
}
fstring("{2} soy {1} {3}", c("Ignacio", "hola", "Chang"))
fstring <- function(pat, vect) {
idxs <- as.numeric(regmatches(pat, gregexpr("(?<=\\{).+?(?=\\})", pat, perl = T))[[1]])
invisible(lapply(idxs, function(i) { pat <<- gsub(paste0("\\{",i,"\\}"), vect[i], pat) }))
return(
pat
)
}
fstring("{2} soy {1} {3}", c("Ignacio", "hola", "Chang"))
fstring <- function(pat, vect) {
idxs <- as.numeric(regmatches(pat, gregexpr("(?<=\\{).+?(?=\\})", pat, perl = T))[[1]])
invisible(lapply(idxs, function(i) { pat <<- gsub(paste0("\\{",i,"\\}"), vect[i], pat) }))
return(pat)
}
fstring("{2} soy {1} {3}", c("Ignacio", "hola", "Chang"))
